# 実装ルール・ガイドライン

本プロジェクトの「シンプルな Feature-First + Repository」アーキテクチャに則った実装ルールを定義します。

---

## 📋 目次

1. [ディレクトリ構成ルール](#ディレクトリ構成ルール)
2. [層ごとの実装ルール](#層ごとの実装ルール)
3. [依存性注入（DI）のルール](#依存性注入diのルール)
4. [命名規則](#命名規則)
5. [コーディング規約](#コーディング規約)
6. [禁止事項](#禁止事項)
7. [チェックリスト](#チェックリスト)

---

## ディレクトリ構成ルール

### 新機能追加時のディレクトリ作成

新しい機能を追加する際は、以下の構造を必ず守ること：

```
lib/features/<feature_name>/
├── datasources/             # データソース（API/DB/SharedPreferences）
│   └── <feature>_data_source.dart
├── dto/                     # データ転送オブジェクト（API通信用）
│   ├── <model>_dto.dart
│   └── <model>_dto.g.dart   # 自動生成
├── entities/                # エンティティ（ビュー用モデル）
│   └── <model>_entity.dart
├── presentation/            # プレゼンテーション層
│   ├── <feature>_view.dart
│   └── <feature>_view_model.dart
└── <feature>_repository.dart # リポジトリ
```

**例: Pokemon機能**
```
lib/features/pokemon/
├── datasources/
│   └── pokemon_data_source.dart        # PokemonApiClient (Retrofit)
├── dto/
│   ├── pokemon_detail_dto.dart
│   ├── pokemon_detail_dto.g.dart
│   ├── pokemon_list_dto.dart
│   └── pokemon_list_dto.g.dart
├── entities/
│   ├── pokemon_entity.dart
│   └── pokemon_list_item_entity.dart
├── presentation/
│   ├── pokemon_list_view.dart
│   ├── pokemon_list_view_model.dart
│   ├── pokemon_detail_view.dart
│   └── pokemon_detail_view_model.dart
└── pokemon_repository.dart
```

### 共有機能の配置

複数の Feature で使用する機能は `shared/` に配置：

```
lib/shared/<feature_name>/
├── datasources/          # データソース
├── entities/             # エンティティ
├── presentation/
│   └── widgets/          # 共有ウィジェット
└── <feature>_repository.dart
```

**例: Auth機能**
```
lib/shared/auth/
├── datasources/
│   └── user_data_source.dart
├── entities/
│   └── user_entity.dart
├── presentation/
│   └── widgets/
│       └── user_switcher.dart
└── user_repository.dart
```

### 技術的インフラの配置

技術的な設定やユーティリティは `core/` に配置：

```
lib/core/
├── di/       # 依存性注入（DI）の中央管理
├── network/  # ネットワーク設定（Dio）
├── router/   # ルーティング（go_router）
├── theme/    # テーマ設定
└── utils/    # ユーティリティ
```

---

## 層ごとの実装ルール

### DataSource 層のルール

#### ✅ やるべきこと

1. **API/DB/SharedPreferencesとのやり取りを担当**

   - 外部データとの通信のみを担当
   - DTOの生成・パースを実施
   - ビジネスロジックは書かない

2. **基本的にremote/localで分けない**

   - 1つのデータソースファイルにまとめる
   - 例外: 責務が明確に分かれている場合は分割可能

   ```dart
   // pokemon_data_source.dart
   @RestApi(baseUrl: 'https://pokeapi.co/api/v2/')
   abstract class PokemonDataSource {
     factory PokemonDataSource(Dio dio) = _PokemonDataSource;

     @GET('/pokemon')
     Future<PokemonListDto> getPokemonList(
       @Query('limit') int limit,
       @Query('offset') int offset,
     );

     @GET('/pokemon/{id}')
     Future<PokemonDetailDto> getPokemonDetail(@Path('id') int id);
   }
   ```

3. **分割が必要な場合の例**

   ```dart
   // survey_local_data_source.dart
   class SurveyLocalDataSource {
     final SharedPreferences _prefs;

     SurveyLocalDataSource(this._prefs);

     Future<SurveyAnswerDto?> getSavedAnswer() async {
       final json = _prefs.getString('survey_answer');
       if (json == null) return null;
       return SurveyAnswerDto.fromJson(jsonDecode(json));
     }

     Future<void> saveAnswer(SurveyAnswerDto dto) async {
       await _prefs.setString('survey_answer', jsonEncode(dto.toJson()));
     }
   }

   // survey_remote_data_source.dart
   class SurveyRemoteDataSource {
     final Dio _dio;

     SurveyRemoteDataSource(this._dio);

     Future<RecommendationDto> getRecommendation(SurveyAnswerDto dto) async {
       final response = await _dio.post('/recommendation', data: dto.toJson());
       return RecommendationDto.fromJson(response.data);
     }
   }
   ```

#### ❌ やってはいけないこと

- ❌ ビジネスロジックを書く（Repository の役割）
- ❌ Entity を直接扱う（DTOのみを使用）
- ❌ UI に関する処理を書く

---

### DTO 層のルール

#### ✅ やるべきこと

1. **DTOはAPIレスポンス/リクエストの構造をそのまま表現**

   - `@JsonSerializable()` を使用
   - API仕様に忠実なデータ構造

   ```dart
   // pokemon_detail_dto.dart
   import 'package:json_annotation/json_annotation.dart';

   part 'pokemon_detail_dto.g.dart';

   /// ポケモン詳細DTO（APIレスポンス）
   ///
   /// PokeAPI の /pokemon/{id} エンドポイントからのレスポンス。
   @JsonSerializable()
   class PokemonDetailDto {
     final int id;
     final String name;
     final int height;
     final int weight;
     final SpritesDto sprites;
     final List<TypeSlotDto> types;
     final List<StatSlotDto> stats;

     PokemonDetailDto({
       required this.id,
       required this.name,
       required this.height,
       required this.weight,
       required this.sprites,
       required this.types,
       required this.stats,
     });

     factory PokemonDetailDto.fromJson(Map<String, dynamic> json) =>
         _$PokemonDetailDtoFromJson(json);

     Map<String, dynamic> toJson() => _$PokemonDetailDtoToJson(this);
   }
   ```

2. **ネストした構造もDTOとして定義**

   ```dart
   @JsonSerializable()
   class SpritesDto {
     final OtherSpritesDto? other;

     SpritesDto({this.other});

     factory SpritesDto.fromJson(Map<String, dynamic> json) =>
         _$SpritesDtoFromJson(json);
   }

   @JsonSerializable()
   class OtherSpritesDto {
     @JsonKey(name: 'official-artwork')
     final OfficialArtworkDto? officialArtwork;

     OtherSpritesDto({this.officialArtwork});

     factory OtherSpritesDto.fromJson(Map<String, dynamic> json) =>
         _$OtherSpritesDtoFromJson(json);
   }
   ```

#### ❌ やってはいけないこと

- ❌ DTOをViewModelやViewで直接使用する
- ❌ DTOにビジネスロジックを書く
- ❌ DTOをEntityに変換するメソッドをDTO内に書く（Repositoryで実施）

---

### Entity 層のルール

#### ✅ やるべきこと

1. **UIに最適化されたデータ構造**

   - ViewとViewModelが使用する
   - 不要な情報は含めない
   - イミュータブル（不変）にする

   ```dart
   // pokemon_entity.dart
   /// ポケモン詳細エンティティ（ビュー用モデル）
   ///
   /// DTOから変換されて生成され、UIに最適化されたデータ構造を持つ。
   class Pokemon {
     final int id;
     final String name;
     final String imageUrl;       // DTOから抽出・整形済み
     final List<String> types;    // DTOから抽出・整形済み
     final int height;
     final int weight;
     final List<PokemonStat> stats; // DTOから抽出・整形済み

     const Pokemon({
       required this.id,
       required this.name,
       required this.imageUrl,
       required this.types,
       required this.height,
       required this.weight,
       required this.stats,
     });
   }

   /// ポケモンのステータス
   class PokemonStat {
     final String name;
     final int value;

     const PokemonStat({
       required this.name,
       required this.value,
     });
   }
   ```

2. **リストアイテム用のEntityを別途定義**

   ```dart
   // pokemon_list_item_entity.dart
   /// ポケモン一覧アイテムエンティティ
   ///
   /// 一覧表示に必要な最小限の情報のみを持つ。
   class PokemonListItem {
     final String name;
     final String url;

     const PokemonListItem({
       required this.name,
       required this.url,
     });

     /// URLからポケモンIDを抽出
     int get id {
       final segments = url.split('/');
       return int.parse(segments[segments.length - 2]);
     }
   }
   ```

#### ❌ やってはいけないこと

- ❌ JSON シリアライゼーションを持つ（DTOの役割）
- ❌ APIの構造に依存する
- ❌ mutable（可変）なフィールドを持つ

---

### Repository 層のルール

#### ✅ やるべきこと

1. **DTO→Entity変換を担当**

   - これはRepositoryの最重要責務
   - ViewModelにはEntityのみを返す

   ```dart
   // pokemon_repository.dart
   /// ポケモンリポジトリ
   ///
   /// データソースの抽象化とDTO→Entity変換を担当。
   /// ViewModelには変換済みのEntityを返す。
   class PokemonRepository {
     final PokemonDataSource dataSource;

     PokemonRepository(this.dataSource);

     /// ポケモン一覧を取得（Entityを返す）
     Future<List<PokemonListItem>> getPokemonList({
       required int limit,
       required int offset,
     }) async {
       final dto = await dataSource.getPokemonList(limit, offset);

       // DTO→Entity変換（Repositoryの責務）
       return dto.results.map((item) {
         return PokemonListItem(
           name: item.name,
           url: item.url,
         );
       }).toList();
     }

     /// ポケモン詳細を取得（Entityを返す）
     Future<Pokemon> getPokemonDetail(int id) async {
       final dto = await dataSource.getPokemonDetail(id);

       // 複雑な変換処理もRepositoryで実施（Repositoryの責務）
       final imageUrl = dto.sprites.other?.officialArtwork?.frontDefault ??
           'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/$id.png';

       final types = dto.types
           .map((typeSlot) => typeSlot.type.name)
           .toList();

       final stats = dto.stats.map((statSlot) {
         return PokemonStat(
           name: statSlot.stat.name,
           value: statSlot.baseStat,
         );
       }).toList();

       return Pokemon(
         id: dto.id,
         name: dto.name,
         imageUrl: imageUrl,
         types: types,
         height: dto.height,
         weight: dto.weight,
         stats: stats,
       );
     }
   }
   ```

2. **複数のデータソースを統合**

   ```dart
   // survey_repository.dart
   class SurveyRepository {
     final SurveyLocalDataSource _localDataSource;
     final SurveyRemoteDataSource _remoteDataSource;

     SurveyRepository(
       this._localDataSource,
       this._remoteDataSource,
     );

     /// アンケート結果をローカルに保存（Entityを受け取る）
     Future<void> saveSurveyAnswer(SurveyAnswer answer) async {
       // EntityをDTOに変換してから保存
       final dto = SurveyAnswerDto(
         favoriteType: answer.favoriteType,
         preferredSize: answer.preferredSize,
         personality: answer.personality,
         battleStyle: answer.battleStyle,
       );
       await _localDataSource.saveSurveyAnswer(dto);
     }

     /// 保存されたアンケート結果を取得（Entityを返す）
     Future<SurveyAnswer?> getSavedSurveyAnswer() async {
       final dto = await _localDataSource.getSavedSurveyAnswer();
       if (dto == null) return null;

       // DTOをEntityに変換
       return SurveyAnswer(
         favoriteType: dto.favoriteType,
         preferredSize: dto.preferredSize,
         personality: dto.personality,
         battleStyle: dto.battleStyle,
       );
     }

     /// おすすめのポケモンIDを取得（Entityを受け取り、結果を返す）
     Future<int> getRecommendedPokemonId(SurveyAnswer answer) async {
       // EntityをDTOに変換
       final dto = SurveyAnswerDto(
         favoriteType: answer.favoriteType,
         preferredSize: answer.preferredSize,
         personality: answer.personality,
         battleStyle: answer.battleStyle,
       );

       final response = await _remoteDataSource.getRecommendation(dto);
       return response.pokemonId;
     }
   }
   ```

3. **ビジネスロジックの一部を担当**

   - データ整形
   - バリデーション
   - キャッシング戦略
   - 複数データソースの統合ロジック

#### ❌ やってはいけないこと

- ❌ DTOをそのままViewModelに返す
- ❌ UIに関する処理を書く
- ❌ ViewModelのような状態管理を持つ

---

### Presentation 層のルール

#### ✅ やるべきこと

1. **ViewModel は Riverpod Notifier で実装**

   - `@riverpod` アノテーションを使用
   - **ビジネスロジックを担当**（UseCaseの代わり）
   - 状態管理はイミュータブルな State クラス

   ```dart
   // pokemon_list_view_model.dart
   import 'package:riverpod_annotation/riverpod_annotation.dart';
   import 'package:work/features/pokemon/entities/pokemon_list_item_entity.dart';
   import 'package:work/core/di/pokemon_di.dart';

   part 'pokemon_list_view_model.g.dart';

   /// ポケモン一覧の状態
   class PokemonListState {
     final List<PokemonListItem> pokemons;
     final bool isLoading;
     final bool isLoadingMore;
     final bool hasMore;
     final String? errorMessage;

     const PokemonListState({
       this.pokemons = const [],
       this.isLoading = false,
       this.isLoadingMore = false,
       this.hasMore = true,
       this.errorMessage,
     });

     PokemonListState copyWith({
       List<PokemonListItem>? pokemons,
       bool? isLoading,
       bool? isLoadingMore,
       bool? hasMore,
       String? errorMessage,
     }) {
       return PokemonListState(
         pokemons: pokemons ?? this.pokemons,
         isLoading: isLoading ?? this.isLoading,
         isLoadingMore: isLoadingMore ?? this.isLoadingMore,
         hasMore: hasMore ?? this.hasMore,
         errorMessage: errorMessage ?? this.errorMessage,
       );
     }
   }

   @riverpod
   class PokemonListViewModel extends _$PokemonListViewModel {
     static const int _pageSize = 20;
     int _currentOffset = 0;

     @override
     PokemonListState build() {
       Future.microtask(() => loadInitialPokemons());
       return const PokemonListState(hasMore: true);
     }

     /// 初回ロード
     Future<void> loadInitialPokemons() async {
       state = state.copyWith(isLoading: true, errorMessage: null);
       _currentOffset = 0;

       try {
         final repository = ref.read(pokemonRepositoryProvider);
         
         // Repositoryから変換済みのEntityが返ってくる
         final pokemons = await repository.getPokemonList(
           limit: _pageSize,
           offset: _currentOffset,
         );

         state = state.copyWith(
           pokemons: pokemons,
           isLoading: false,
           hasMore: pokemons.length == _pageSize,
         );
         _currentOffset += _pageSize;
       } catch (e) {
         state = state.copyWith(
           isLoading: false,
           errorMessage: 'ポケモンの読み込みに失敗しました: $e',
         );
       }
     }

     /// 追加読み込み
     Future<void> loadMorePokemons() async {
       if (state.isLoadingMore || !state.hasMore) return;

       state = state.copyWith(isLoadingMore: true);

       try {
         final repository = ref.read(pokemonRepositoryProvider);
         final newPokemons = await repository.getPokemonList(
           limit: _pageSize,
           offset: _currentOffset,
         );

         state = state.copyWith(
           pokemons: [...state.pokemons, ...newPokemons],
           isLoadingMore: false,
           hasMore: newPokemons.length == _pageSize,
         );
         _currentOffset += _pageSize;
       } catch (e) {
         state = state.copyWith(
           isLoadingMore: false,
           errorMessage: 'ポケモンの追加読み込みに失敗しました: $e',
         );
       }
     }
   }
   ```

2. **State クラスは `copyWith` を実装**

   - イミュータブルな状態更新のため
   - nullable なフィールドも適切に扱う

3. **View は ConsumerWidget または HookConsumerWidget**

   - UIの描画のみを担当
   - ビジネスロジックは書かない

   ```dart
   // pokemon_list_view.dart
   class PokemonListView extends HookConsumerWidget {
     const PokemonListView({super.key});

     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final state = ref.watch(pokemonListViewModelProvider);
       final viewModel = ref.read(pokemonListViewModelProvider.notifier);

       // スクロール監視
       final scrollController = useScrollController();
       useEffect(() {
         void onScroll() {
           if (scrollController.position.pixels >=
               scrollController.position.maxScrollExtent * 0.9) {
             viewModel.loadMorePokemons();
           }
         }
         scrollController.addListener(onScroll);
         return () => scrollController.removeListener(onScroll);
       }, [scrollController]);

       return Scaffold(
         appBar: AppBar(title: const Text('ポケモン図鑑')),
         body: state.isLoading
             ? const Center(child: CircularProgressIndicator())
             : ListView.builder(
                 controller: scrollController,
                 itemCount: state.pokemons.length + (state.hasMore ? 1 : 0),
                 itemBuilder: (context, index) {
                   // UI実装...
                 },
               ),
       );
     }
   }
   ```

#### ❌ やってはいけないこと

- ❌ View から直接 Repository や DataSource を呼ぶ
- ❌ ViewModel で直接 DataSource を呼ぶ（Repositoryを経由）
- ❌ State を直接変更する（必ず `copyWith` を使う）
- ❌ ViewModel に UI ロジック（色、サイズなど）を書く

---

## 依存性注入（DI）のルール

### DI ファイルの配置

全ての DI 設定は `lib/core/di/` に集約：

```dart
// lib/core/di/pokemon_di.dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:work/features/pokemon/datasources/pokemon_data_source.dart';
import 'package:work/features/pokemon/pokemon_repository.dart';
import 'package:work/core/network/dio_client.dart';

part 'pokemon_di.g.dart';

/// ========================================
/// Pokemon - Dependency Injection
/// ========================================

/// PokemonApiClientプロバイダー
@riverpod
PokemonDataSource pokemonDataSource(PokemonDataSourceRef ref) {
  final dio = ref.watch(dioProvider);
  return PokemonDataSource(dio);
}

/// PokemonRepositoryプロバイダー
@riverpod
PokemonRepository pokemonRepository(PokemonRepositoryRef ref) {
  final dataSource = ref.watch(pokemonDataSourceProvider);
  return PokemonRepository(dataSource);
}
```

### DI の依存関係

```
Dio → DataSource → Repository → ViewModel
```

各層は 1 つ下の層のみに依存する。

### 共通のプロバイダー

共通で使用するプロバイダーは `core/network/` などに配置：

```dart
// lib/core/network/dio_client.dart
import 'package:dio/dio.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'dio_client.g.dart';

@riverpod
Dio dio(DioRef ref) {
  final dio = Dio(BaseOptions(
    connectTimeout: const Duration(seconds: 30),
    receiveTimeout: const Duration(seconds: 30),
  ));

  // インターセプターなどの設定
  dio.interceptors.add(LogInterceptor(
    requestBody: true,
    responseBody: true,
  ));

  return dio;
}
```

---

## 命名規則

### ファイル名

- **スネークケース** を使用
- 末尾の規則を厳守

| 種類 | 命名規則 | 例 |
|------|---------|-----|
| DataSource | `<feature>_data_source.dart` | `pokemon_data_source.dart` |
| DTO | `<model>_dto.dart` | `pokemon_detail_dto.dart` |
| Entity | `<model>_entity.dart` | `pokemon_entity.dart` |
| Repository | `<feature>_repository.dart` | `pokemon_repository.dart` |
| View | `<feature>_view.dart` | `pokemon_list_view.dart` |
| ViewModel | `<feature>_view_model.dart` | `pokemon_list_view_model.dart` |
| State | `<feature>_state.dart` | `pokemon_list_state.dart` |

### クラス名

| 種類 | 命名規則 | 例 |
|------|---------|-----|
| DataSource | `<Feature>DataSource` | `PokemonDataSource` |
| DTO | `<ModelName>Dto` | `PokemonDetailDto` |
| Entity | `<ModelName>` | `Pokemon`, `PokemonListItem` |
| Repository | `<Feature>Repository` | `PokemonRepository` |
| ViewModel | `<Feature>ViewModel` | `PokemonListViewModel` |
| View | `<Feature>View` | `PokemonListView` |
| State | `<Feature>State` | `PokemonListState` |

---

## コーディング規約

### Import の順序

1. Dart SDK
2. Flutter SDK
3. 外部パッケージ
4. 自プロジェクト

```dart
import 'dart:async';

import 'package:flutter/material.dart';

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';

import 'package:work/core/di/pokemon_di.dart';
import 'package:work/features/pokemon/entities/pokemon_entity.dart';
```

### コメント

- クラスには必ずドキュメントコメント（`///`）を書く
- 複雑なロジックには説明コメントを書く
- DTO・Entity・Repositoryには役割を明記

```dart
/// ポケモン詳細DTO（APIレスポンス）
///
/// PokeAPI の /pokemon/{id} エンドポイントからのレスポンス。
/// このDTOはRepositoryでEntityに変換される。
@JsonSerializable()
class PokemonDetailDto {
  // ...
}

/// ポケモン詳細エンティティ（ビュー用モデル）
///
/// DTOから変換されて生成され、UIに最適化されたデータ構造を持つ。
class Pokemon {
  // ...
}

/// ポケモンリポジトリ
///
/// データソースの抽象化とDTO→Entity変換を担当。
/// ViewModelには変換済みのEntityを返す。
class PokemonRepository {
  // ...
}
```

### コード生成

以下のファイルは必ずコード生成を実行：

```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

- `@JsonSerializable()` を使った DTO
- `@riverpod` を使った Provider
- `@RestApi()` を使った DataSource

---

## 禁止事項

### 🚫 絶対にやってはいけないこと

1. **層をまたいだ不適切な依存**

   - ❌ ViewModel から DataSource を直接呼ぶ（Repositoryを経由）
   - ❌ View から Repository を直接呼ぶ（ViewModelを経由）
   - ❌ Repository から ViewModel を参照

2. **DTOとEntityの混同**

   - ❌ DTOをViewModelやViewで使用
   - ❌ EntityにJSON シリアライゼーションを持たせる
   - ❌ RepositoryがDTOを返す

3. **循環参照**

   - ❌ A が B に依存し、B が A に依存する

4. **グローバル変数の使用**

   - ❌ `static` なグローバル変数でデータを保持
   - ✅ Riverpodのプロバイダーを使用

5. **ハードコーディング**

   - ❌ URL やキーを直接コードに書く
   - ✅ 環境変数や定数ファイルを使用

6. **巨大なファイル**

   - ❌ 1 ファイルに複数の責務を持つクラスを詰め込む
   - ✅ 1 ファイル = 1 クラス（State クラスなどの小規模クラスは例外）

7. **State の直接変更**
   - ❌ `state.pokemons.add(newPokemon)` のような変更
   - ✅ `state = state.copyWith(pokemons: [...state.pokemons, newPokemon])`

---

## チェックリスト

### 新機能実装時のチェックリスト

#### ディレクトリ構成
- [ ] `datasources/` ディレクトリを作成したか？
- [ ] `dto/` ディレクトリを作成したか？
- [ ] `entities/` ディレクトリを作成したか？
- [ ] `presentation/` ディレクトリを作成したか？
- [ ] Repository ファイルを作成したか？

#### 命名規則
- [ ] DataSource: `*_data_source.dart` / `*DataSource`
- [ ] DTO: `*_dto.dart` / `*Dto`
- [ ] Entity: `*_entity.dart` / `*`
- [ ] Repository: `*_repository.dart` / `*Repository`
- [ ] View: `*_view.dart` / `*View`
- [ ] ViewModel: `*_view_model.dart` / `*ViewModel`

#### 実装内容
- [ ] DTO に `@JsonSerializable()` を付けたか？
- [ ] Entity は UI に最適化されているか？
- [ ] Repository は DTO → Entity 変換しているか？
- [ ] Repository は Entity のみを返しているか？
- [ ] ViewModel は Riverpod Notifier で実装したか？
- [ ] State クラスに `copyWith` を実装したか？
- [ ] View はビジネスロジックを持っていないか？

#### DI設定
- [ ] DI 設定を `core/di/<feature>_di.dart` に追加したか？
- [ ] DataSource → Repository → ViewModel の依存関係は正しいか？

#### コード生成・品質
- [ ] `build_runner` を実行したか？
- [ ] `flutter analyze` でエラーがないか？
- [ ] 適切なコメントを書いたか？
- [ ] Import の順序は正しいか？

---

## よくある実装パターン

### パターン1: ページネーション

```dart
@riverpod
class ListViewModel extends _$ListViewModel {
  int _offset = 0;
  static const int _limit = 20;

  @override
  ListState build() {
    Future.microtask(() => loadInitial());
    return const ListState();
  }

  Future<void> loadInitial() async {
    _offset = 0;
    state = state.copyWith(isLoading: true);
    
    try {
      final items = await ref.read(repositoryProvider).getList(
        limit: _limit,
        offset: _offset,
      );
      
      state = state.copyWith(
        items: items,
        isLoading: false,
        hasMore: items.length == _limit,
      );
      _offset += _limit;
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: 'エラー: $e',
      );
    }
  }

  Future<void> loadMore() async {
    if (state.isLoadingMore || !state.hasMore) return;
    
    state = state.copyWith(isLoadingMore: true);
    
    try {
      final items = await ref.read(repositoryProvider).getList(
        limit: _limit,
        offset: _offset,
      );
      
      state = state.copyWith(
        items: [...state.items, ...items],
        isLoadingMore: false,
        hasMore: items.length == _limit,
      );
      _offset += _limit;
    } catch (e) {
      state = state.copyWith(isLoadingMore: false);
    }
  }
}
```

### パターン2: 複数データソースの統合

```dart
class CachedRepository {
  final RemoteDataSource _remote;
  final LocalDataSource _local;

  CachedRepository(this._remote, this._local);

  Future<Item> getItem(int id) async {
    // まずローカルキャッシュを確認
    final cached = await _local.getItem(id);
    if (cached != null && !_isExpired(cached)) {
      // キャッシュが有効ならEntityに変換して返す
      return _dtoToEntity(cached);
    }

    // キャッシュがないか期限切れならリモートから取得
    final dto = await _remote.getItem(id);
    
    // ローカルにキャッシュ
    await _local.saveItem(dto);
    
    // Entityに変換して返す
    return _dtoToEntity(dto);
  }

  bool _isExpired(ItemDto dto) {
    // キャッシュの有効期限チェック
    return DateTime.now().difference(dto.cachedAt) > const Duration(hours: 1);
  }

  Item _dtoToEntity(ItemDto dto) {
    // DTO→Entity変換
    return Item(
      id: dto.id,
      name: dto.name,
      // ...
    );
  }
}
```

### パターン3: フォーム送信

```dart
@riverpod
class FormViewModel extends _$FormViewModel {
  @override
  FormState build() => const FormState();

  Future<void> submit(FormData data) async {
    if (!_validate(data)) {
      state = state.copyWith(errorMessage: 'バリデーションエラー');
      return;
    }

    state = state.copyWith(isSubmitting: true, errorMessage: null);

    try {
      // EntityからDTOに変換してRepository経由で送信
      await ref.read(repositoryProvider).submitForm(data);
      
      state = state.copyWith(
        isSubmitting: false,
        isSuccess: true,
      );
    } catch (e) {
      state = state.copyWith(
        isSubmitting: false,
        errorMessage: '送信に失敗しました: $e',
      );
    }
  }

  bool _validate(FormData data) {
    // バリデーションロジック
    return data.name.isNotEmpty && data.email.contains('@');
  }
}
```

---

## 参考資料

- [Clean Architecture (Uncle Bob)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Riverpod Documentation](https://riverpod.dev/)
- [Retrofit Documentation](https://pub.dev/packages/retrofit)
- [json_serializable Documentation](https://pub.dev/packages/json_serializable)

---
