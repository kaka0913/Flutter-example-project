# 実装ルール・ガイドライン

本プロジェクトのアーキテクチャに則った実装ルールを定義します。

---

## 📋 目次

1. [ディレクトリ構成ルール](#ディレクトリ構成ルール)
2. [層ごとの実装ルール](#層ごとの実装ルール)
3. [依存性注入（DI）のルール](#依存性注入diのルール)
4. [命名規則](#命名規則)
5. [コーディング規約](#コーディング規約)
6. [禁止事項](#禁止事項)

---

## ディレクトリ構成ルール

### 新機能追加時のディレクトリ作成

新しい機能を追加する際は、以下の構造を必ず守ること：

```
lib/features/<feature_name>/
├── domain/
│   ├── entities/      # ビジネスエンティティ
│   ├── repositories/  # Repository インターフェース
│   └── usecases/      # UseCase
├── data/
│   ├── models/        # DTOs (json_serializable)
│   ├── datasources/   # DataSource (API, DB)
│   └── repositories/  # Repository 実装
└── presentation/
    ├── view_models/   # ViewModel (Riverpod Notifier)
    └── views/         # View (Widget)
```

### 共有機能の配置

複数の Feature で使用する機能は `shared/` に配置：

```
lib/shared/<feature_name>/
├── domain/
├── data/
└── presentation/
    └── widgets/  # 共有ウィジェット
```

### 技術的インフラの配置

技術的な設定やユーティリティは `core/` に配置：

```
lib/core/
├── di/       # 依存性注入
├── network/  # ネットワーク設定
├── router/   # ルーティング
├── theme/    # テーマ
└── utils/    # ユーティリティ
```

---

## 層ごとの実装ルール

### Domain 層のルール

#### ✅ やるべきこと

1. **純粋な Dart コードのみ使用**

   - Flutter SDK や外部パッケージに依存しない
   - 例外: Dart の標準ライブラリは OK

2. **Entity は不変（Immutable）にする**

   ```dart
   class Pokemon {
     final int id;
     final String name;

     const Pokemon({
       required this.id,
       required this.name,
     });
   }
   ```

3. **Repository はインターフェース（abstract class）として定義**

   ```dart
   abstract class PokemonRepository {
     Future<List<PokemonListItem>> getPokemonList({
       required int limit,
       required int offset,
     });

     Future<Pokemon> getPokemonDetail(int id);
   }
   ```

4. **UseCase は単一責任の原則に従う**

   - 1 つの UseCase は 1 つのビジネスロジックのみを担当
   - `call()` メソッドで実装

   ```dart
   class GetPokemonListUseCase {
     final PokemonRepository repository;

     GetPokemonListUseCase(this.repository);

     Future<List<PokemonListItem>> call({
       required int limit,
       required int offset,
     }) async {
       return await repository.getPokemonList(
         limit: limit,
         offset: offset,
       );
     }
   }
   ```

#### ❌ やってはいけないこと

- ❌ Flutter SDK（`import 'package:flutter/...'`）を使用する
- ❌ 外部パッケージ（Dio、Retrofit 等）に依存する
- ❌ UI に関する処理を書く
- ❌ データの取得・保存の具体的な実装を書く

---

### Data 層のルール

#### ✅ やるべきこと

1. **Model は DTO として扱う**

   - JSON シリアライゼーション専用
   - `@JsonSerializable()` を使用

   ```dart
   @JsonSerializable()
   class PokemonDetailResponse {
     final int id;
     final String name;
     final int height;
     final int weight;

     PokemonDetailResponse({
       required this.id,
       required this.name,
       required this.height,
       required this.weight,
     });

     factory PokemonDetailResponse.fromJson(Map<String, dynamic> json) =>
         _$PokemonDetailResponseFromJson(json);

     Map<String, dynamic> toJson() => _$PokemonDetailResponseToJson(this);
   }
   ```

2. **Repository 実装は Domain の Repository インターフェースを implements**

   ```dart
   class PokemonRepositoryImpl implements PokemonRepository {
     final PokemonApiClient apiClient;

     PokemonRepositoryImpl(this.apiClient);

     @override
     Future<Pokemon> getPokemonDetail(int id) async {
       final response = await apiClient.getPokemonDetail(id);
       return _responseToEntity(response);
     }

     // DTO → Entity の変換
     Pokemon _responseToEntity(PokemonDetailResponse dto) {
       return Pokemon(
         id: dto.id,
         name: dto.name,
         // ... その他のフィールド
       );
     }
   }
   ```

3. **DataSource は具体的な技術に依存して OK**

   - Retrofit、Dio、SharedPreferences など

   ```dart
   @RestApi(baseUrl: 'https://pokeapi.co/api/v2')
   abstract class PokemonApiClient {
     factory PokemonApiClient(Dio dio) = _PokemonApiClient;

     @GET('/pokemon')
     Future<PokemonListResponse> getPokemonList(
       @Query('limit') int limit,
       @Query('offset') int offset,
     );
   }
   ```

#### ❌ やってはいけないこと

- ❌ Domain 層の Entity を直接 JSON に変換する
- ❌ ビジネスロジックを書く（それは UseCase の役割）
- ❌ UI に関する処理を書く

---

### Presentation 層のルール

#### ✅ やるべきこと

1. **ViewModel は Riverpod Notifier で実装**

   - `@riverpod` アノテーションを使用
   - 状態管理はイミュータブルな State クラス

   ```dart
   @riverpod
   class PokemonListViewModel extends _$PokemonListViewModel {
     late final GetPokemonListUseCase _useCase;

     @override
     PokemonListState build() {
       _useCase = ref.watch(getPokemonListUseCaseProvider);
       Future.microtask(() => loadInitialPokemons());
       return const PokemonListState(hasMore: true);
     }

     Future<void> loadInitialPokemons() async {
       state = state.copyWith(isLoading: true);
       try {
         final pokemons = await _useCase(limit: 20, offset: 0);
         state = state.copyWith(
           pokemons: pokemons,
           isLoading: false,
         );
       } catch (e) {
         state = state.copyWith(
           isLoading: false,
           errorMessage: 'エラー: $e',
         );
       }
     }
   }
   ```

2. **State クラスは `copyWith` を実装**

   ```dart
   class PokemonListState {
     final List<PokemonListItem> pokemons;
     final bool isLoading;
     final String? errorMessage;

     const PokemonListState({
       this.pokemons = const [],
       this.isLoading = false,
       this.errorMessage,
     });

     PokemonListState copyWith({
       List<PokemonListItem>? pokemons,
       bool? isLoading,
       String? errorMessage,
     }) {
       return PokemonListState(
         pokemons: pokemons ?? this.pokemons,
         isLoading: isLoading ?? this.isLoading,
         errorMessage: errorMessage ?? this.errorMessage,
       );
     }
   }
   ```

3. **View は ConsumerWidget または HookConsumerWidget**

   ```dart
   class PokemonListView extends HookConsumerWidget {
     const PokemonListView({super.key});

     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final state = ref.watch(pokemonListViewModelProvider);
       final viewModel = ref.read(pokemonListViewModelProvider.notifier);

       // UI の実装
     }
   }
   ```

#### ❌ やってはいけないこと

- ❌ ViewModel にビジネスロジックを書く（UseCase を使う）
- ❌ View から直接 Repository や DataSource を呼ぶ
- ❌ ViewModel で直接 API を呼ぶ
- ❌ State を直接変更する（必ず `copyWith` を使う）

---

## 依存性注入（DI）のルール

### DI ファイルの配置

全ての DI 設定は `lib/core/di/` に集約：

```dart
// lib/core/di/pokemon_di.dart
@riverpod
PokemonApiClient pokemonApiClient(Ref ref) {
  final dio = ref.watch(dioProvider);
  return PokemonApiClient(dio);
}

@riverpod
PokemonRepository pokemonRepository(Ref ref) {
  final apiClient = ref.watch(pokemonApiClientProvider);
  return PokemonRepositoryImpl(apiClient);
}

@riverpod
GetPokemonListUseCase getPokemonListUseCase(Ref ref) {
  final repository = ref.watch(pokemonRepositoryProvider);
  return GetPokemonListUseCase(repository);
}
```

### DI の依存関係

```
Dio → DataSource → Repository → UseCase → ViewModel
```

各層は 1 つ下の層のみに依存する。

---

## 命名規則

### ファイル名

- **スネークケース** を使用
- 例: `pokemon_list_view.dart`, `get_pokemon_list_usecase.dart`

### クラス名

| 種類                 | 命名規則                       | 例                                        |
| -------------------- | ------------------------------ | ----------------------------------------- |
| Entity               | 名詞                           | `Pokemon`, `User`                         |
| Repository Interface | `<Entity>Repository`           | `PokemonRepository`                       |
| Repository Impl      | `<Entity>RepositoryImpl`       | `PokemonRepositoryImpl`                   |
| UseCase              | `<動詞><対象>UseCase`          | `GetPokemonListUseCase`                   |
| DataSource           | `<Entity><種類>DataSource`     | `PokemonApiClient`, `UserLocalDataSource` |
| Model (DTO)          | `<Entity><種類>Response/Model` | `PokemonDetailResponse`                   |
| ViewModel            | `<Feature>ViewModel`           | `PokemonListViewModel`                    |
| View                 | `<Feature>View`                | `PokemonListView`                         |
| State                | `<Feature>State`               | `PokemonListState`                        |

---

## コーディング規約

### Import の順序

1. Dart SDK
2. Flutter SDK
3. 外部パッケージ
4. 自プロジェクト

```dart
import 'dart:async';

import 'package:flutter/material.dart';

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';

import 'package:work/core/di/pokemon_di.dart';
import 'package:work/features/pokemon/domain/entities/pokemon.dart';
```

### コメント

- クラスには必ずドキュメントコメント（`///`）を書く
- 複雑なロジックには説明コメントを書く

```dart
/// ポケモン一覧取得UseCase
///
/// PokéAPI からポケモンの一覧を取得します。
/// ページネーションに対応しています。
class GetPokemonListUseCase {
  // ...
}
```

### コード生成

以下のファイルは必ずコード生成を実行：

```bash
fvm flutter pub run build_runner build --delete-conflicting-outputs
```

- `@JsonSerializable()` を使った Model
- `@riverpod` を使った Provider
- `@RestApi()` を使った API Client

---

## 禁止事項

### 🚫 絶対にやってはいけないこと

1. **層をまたいだ依存**

   - ❌ Domain 層から Data 層や Presentation 層をインポート
   - ❌ UseCase から ViewModel を呼ぶ

2. **循環参照**

   - ❌ A が B に依存し、B が A に依存する

3. **グローバル変数の使用**

   - ❌ `static` なグローバル変数でデータを保持

4. **ハードコーディング**

   - ❌ URL やキーを直接コードに書く
   - ✅ 環境変数や定数ファイルを使用

5. **巨大なファイル**

   - ❌ 1 ファイルに複数の責務を持つクラスを詰め込む
   - ✅ 1 ファイル = 1 クラス（State クラスは例外）

6. **直接的な null 返却**
   - ❌ `null` を返すメソッド
   - ✅ `<Type>?` で nullable 型を明示

---

## チェックリスト

新機能実装時のチェックリスト：

- [ ] Domain 層は純粋な Dart コードのみか？
- [ ] Repository インターフェースを定義したか？
- [ ] UseCase は単一責任か？
- [ ] Model に `@JsonSerializable()` を付けたか？
- [ ] Repository 実装は DTO → Entity 変換しているか？
- [ ] ViewModel は Riverpod Notifier で実装したか？
- [ ] State クラスに `copyWith` を実装したか？
- [ ] DI 設定を `core/di/` に追加したか？
- [ ] コード生成を実行したか？
- [ ] `flutter analyze` でエラーがないか？

---

## 参考資料

- [Clean Architecture (Uncle Bob)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Flutter Clean Architecture Tutorial (Reso Coder)](https://resocoder.com/flutter-clean-architecture-tdd/)
- [Riverpod Documentation](https://riverpod.dev/)
